# 实体抽取容错处理说明

## 🐛 问题描述

在实体抽取过程中，偶尔会出现以下错误：
```python
KeyError: key = (rel['source'], rel['target'], rel['relation_type'])
```

## 🔍 问题原因

1. **LLM返回数据不完整**
   - 某些关系对象缺少必需字段（`source`、`target`、`relation_type`）
   - 某些实体对象缺少必需字段（`name`、`entity_type`）

2. **LLM违反规则**
   - 尽管Prompt明确说明，LLM有时仍会提取 `LiteratureSource` 实体
   - LLM可能提取 `SOURCE_FROM` 关系（这些应由系统自动添加）

3. **数据格式问题**
   - 字段值为空字符串
   - 返回的不是字典类型

## ✅ 解决方案

### 1. 实体验证与过滤

```python
# 实体去重（添加数据验证）
for entity in all_entities:
    # 验证实体是否包含必需字段
    if not isinstance(entity, dict):
        invalid_entities.append(("非字典类型", entity))
        continue
    
    # 检查必需字段
    if 'name' not in entity or 'entity_type' not in entity:
        invalid_entities.append(("缺少必需字段", entity))
        continue
    
    # 检查字段值是否有效
    if not entity['name'] or not entity['entity_type']:
        invalid_entities.append(("字段值为空", entity))
        continue
    
    # 🔥 过滤掉LiteratureSource类型（文献来源由系统自动添加）
    if entity['entity_type'] == 'LiteratureSource':
        continue
    
    # ... 继续处理有效实体
```

### 2. 关系验证与过滤

```python
# 关系去重（添加数据验证）
for rel in all_relationships:
    # 验证关系是否包含必需字段
    if not isinstance(rel, dict):
        invalid_relationships.append(("非字典类型", rel))
        continue
    
    # 检查必需字段
    if 'source' not in rel or 'target' not in rel or 'relation_type' not in rel:
        invalid_relationships.append(("缺少必需字段", rel))
        continue
    
    # 检查字段值是否有效
    if not rel['source'] or not rel['target'] or not rel['relation_type']:
        invalid_relationships.append(("字段值为空", rel))
        continue
    
    # 🔥 过滤掉SOURCE_FROM关系（文献来源关系由系统自动添加）
    if rel['relation_type'] == 'SOURCE_FROM':
        continue
    
    # ... 继续处理有效关系
```

### 3. 错误报告

系统现在会详细报告无效数据：

```
  ⚠ 发现 3 个无效实体已忽略
    - 原因: 缺少必需字段, 数据: {'name': '某实体'}
    - 原因: 字段值为空, 数据: {'name': '', 'entity_type': 'Disease'}
    - 原因: 非字典类型, 数据: "某字符串"

  ⚠ 发现 2 个无效关系已忽略
    - 原因: 缺少必需字段, 数据: {'source': '实体A', 'target': '实体B'}
    - 原因: 字段值为空, 数据: {'source': '', 'target': 'X', 'relation_type': 'XX'}
```

## 📋 处理流程

```
原始数据 (LLM返回)
    │
    ▼
┌─────────────────┐
│  数据验证       │
│  - 类型检查     │
│  - 字段检查     │
│  - 值检查       │
└─────────────────┘
    │
    ├─── ✅ 有效数据 ──► 继续处理
    │
    └─── ❌ 无效数据 ──► 记录并忽略
             │
             ▼
        ┌──────────────┐
        │ 特殊过滤     │
        │ - 过滤文献源 │
        │ - 过滤SOURCE │
        └──────────────┘
```

## 🎯 效果

### 修复前
```
❌ 遇到无效数据时程序崩溃
❌ LLM提取的文献来源导致重复
❌ 无法追踪数据问题
```

### 修复后
```
✅ 自动过滤无效数据，程序继续运行
✅ 自动过滤LiteratureSource和SOURCE_FROM
✅ 详细报告数据问题
✅ 保留所有有效数据
```

## 📊 监控指标

系统现在会输出：
```
  处理第 1/10 块...
    ✓ 提取了 15 个实体
    ✓ 提取了 12 个关系
  
  ... (其他块) ...
  
  ⚠ 发现 3 个无效实体已忽略
  ⚠ 发现 2 个无效关系已忽略
  
  ✓ 去重后: 127 个实体, 137 个关系
```

## 🔧 维护建议

1. **监控无效数据**
   - 如果经常出现无效数据，可能需要调整Prompt
   - 检查LLM返回的原始数据

2. **Prompt优化**
   - 在Prompt中更明确地说明不要提取LiteratureSource
   - 强调不要提取SOURCE_FROM关系

3. **扩展验证**
   - 如果发现新的数据问题，在验证代码中添加相应检查
   - 考虑添加实体名称和关系类型的白名单

## 📝 相关文件

- `Construct/knowledge_workflow.py` - 实体抽取主逻辑（已修复）
- `Construct/knowledge_data_manager.py` - 数据管理器
- `backend_api.py` - 后端API

## ✨ 总结

现在系统具备了完善的容错机制：
- ✅ 数据验证
- ✅ 自动过滤
- ✅ 错误报告
- ✅ 不中断流程

即使LLM返回有问题的数据，系统也能正常运行！🎉

